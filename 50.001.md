# Term4-2D-Project (50.001)


Notes:
the codes may need extra imports like:
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.util.Iterator;

To read the cnf file, we first pass the address of the file in the arguments configuration of android studio to a String variable called filename, then we generate a formula  by calling the readFile(filename) method. This readFile() method utilizes the java Scanner which will scan the whole file from a given input filename and iterate through each line using a while loop, splitting the file into clauses for each line, and furthermore into literals. The literals can be positive and negative and we use some an array to store them and generate clauses by running makeCl(Literal[]) on each array of literals (for each line), the code will keep adding clauses to an array until the scanner finished reading every possible line for clause and exits the while loop or when it encounters a null clause. The array of clauses is used to form the complete formula by running makeFm(Clauses[]). This formula passed to the method startSATSolver, where this method basically utilizes the SATSolver and also calculates its duration/processing time and satisfiable/not satisfiable output. If the output is satisfiable the variables alongside their assigned Boolean value will be written to “BoolAssignment.txt” using the Java File Writer.

In the SATSolver itself, we create a Solve(Formula) method that takes in an object of the Formula class as its argument, creates a new Environment represented by the variable “answer”, and overloads a different implementation of solve with 2 arguments, the first one is clauses extracted from the formula using getClauses() and the second one is the Environment. In the implementation of Solve(ImList<Clause> clauses, Environment env),  we use the concept of the DPLL Algorithm. We first check if the list of clauses is empty and returns the environment “env” if it is. Next we declare a variable for the smallest Clause and set it to null. We use a for loop to iterate through every clause (“A” in our case) in the list of clauses and for every instance of a Clause, we check whether it is empty or not, if it is empty it will return the environment as null meaning the problem is unsatisfiable. If the smallest is currently null or the size of the smallest clause is larger than the clause “A” we are currently iterating on, then A will be the new smallest. The next line checks if smallest is an unit clause (size = 1) using .isUnit() method, and if it is then it will break out of the iteration, keeping smallest as its last assigned value, otherwise it will just continue with the iteration until it finds a suitable “smallest” clause which may not be a Unit clause. 
Next we declare a literal “Random_L”, using the .chooseLiteral() method on the smallest clause which will arbitrary pick a literal from the clause, and we also declare a Variable “V_RandomL” using the getVariable method on the literal we just declared. There is a check whether smallest is a unit clause because we want to iterate using the concept of unit propagation focusing on unit clauses first, because the truth value is solely determined by the single literal. In this branch we check if the literal Random_L is equal to the positive (+) of V_RandomL, if it is then it will use putTrue to assign True to the Variable V_RandomL in the Environment, else if the literal is a Negative (-) of the variable, then it will use assign false to the variable. The code will then use substitute method to reduce the clauses based on the literal we are currently checking and recursively call solve with this updated list of clauses after reduction. On the other hand, if the smallest clause we can find is not a unit clause, we use a backtracking concept of searching. We first check if the literal is equal to negative (-) of the variable, if it is, then we use getNegation on that literal otherwise we do not negate the literal since its positive. We then call recursively call the solve method which first runs substitute to once again reduce the clauses based on the literal and we try to set the variable to true and see if it returns a valid environment. If the result of the solve method fail and it returns a null environment, we try to recursive solve it again using substitute on the negation of the literal and setting the variable to be false, we keep backtracking via recursive calls until we can find a valid environment that is not null and returns it to the SATSolver, but if in the end we cannot find one, then the method will return a null environment which is analogous to an unsatisfiable problem. Here we also have exception handling to cater with NullPointerException and make a safe exit.
  
We have a method called substitute(ImList<Clause> clauses, Literal l) which takes in a list of clauses (called “clauses”) and a literal l as the input. It utilizes an Iterator<Clauses> called “Citer” to iterate through each clause in the list of clauses and reduce the clauses as a result of setting literal l to true, the new clauses after reduction will be stored to a new Immutable List of Clauses called “new_clauses”. How this works is that when one of the literals in a Clause is true, since it is a disjunction, the value of the Clause will automatically be true analogous to an OR function, that is why we can reduce the clause to make the problem simpler. We also declare some kind of temporary storage of Clause called “tmp_clause”. Using a while loop, we use the Citer.hasNext() method as the condition to check if the iterator still has another clause in the sequence to evaluate through, if it does then it will set the next clause in line to “tmp_clause” using Citer.next() and subsequently runs the reduce() method of the Clause class using literal l as its argument, and if the reduced clause is not null it will be added to the new list of clauses “new_clauses” using the add() method. In the end of this method, we return the new Immutable List of clauses “new_clauses”. 
  
Results from our test runs are as follows, the result is Unsatisfiable with a running time of 8379.5658 ms and the Specification of the computer used to test run this SATSolver is ASUS VivoBook Intel Core i7-8550U at 1.80 GHz. It is unsatisfiable and returns a null environment, looking at the test_2020.cnf file which is a 3-CNF format we can see that at the last line is a unit clause (~ X5999), where the value of the 5999th literal has to be False in order for the negation to be True and to make the unit clause True. Looking back two lines, the clauses here are in this form (~ (Xi-1) v Xi), since the i-th literal (in this case 5999th) is already False the (i – 1)th literal needs to be False in order to make sure its negation is True and keep the value of the clause to be True, this specific pattern keeps on repeating until it reaches (~ (X60) v (X61)), where both of the literals should be False to make this clause to be True, however if we take a look at the 2nd last line, we see that this is a unit clause with X60 as its sole literal and since we already set the 60th literal to False, this one single clause will in turn make the whole formula unsatisfiable. Because the CNF is conjunction of clauses, if one of the clause is false, since it is connected with AND, all of the formula will be false.

The running time is around ~8000 ms, about half of the expected target of 15 seconds, we are able to achieve this by optimizing the code and deleting unnecessary methods and variables that are not utilized or has a duplicate function to another, and also by reducing the number of clauses with the substitute method, also we utilize the concept of unit propagation to forecast the output, where we inspect clauses with a sole/single variable inside of it. Since the number of clauses is 6000, then it takes approximately 8000/6000 = 1.333 ms to evaluate and check a single clause if it iterates through each clause. The time taken is calculated after passing the formula read from the cnf file to the solve method of the SATSolver until it finishes processing and returns an environment with accuracy regulated by System.nanoTime(). The performance is also affected by the specification of the processor which has a base core speed 1.80 GHz used in most situations but allows the clock to rise up to 4.0 GHz using single core turbo speed when it is needed to process large amount information, the characteristics are set by the manufacturer. This factor is also affected by the TDP (Thermal Design Power) limit which relates to the heat regulating and cooling performance of the processor and denotes the average power the processor dissipates at base frequency.



